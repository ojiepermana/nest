# Enterprise-Level Code Quality & Best Practices

## üéØ Overview

This document defines enterprise-level standards for code generated by @ojiepermana/nest-generator to ensure production-ready, maintainable, and scalable applications.

---

## üèÜ Enterprise Code Quality Standards

### 1. Error Handling & Resilience

**Required Patterns:**

```typescript
// ‚úÖ GOOD: Comprehensive error handling
@Post()
async create(@Body() dto: CreateDto, @Req() req: Request) {
  const correlationId = req.headers['x-correlation-id'] || uuidv4();

  try {
    this.logger.log(`[${correlationId}] Creating entity`, { dto });

    const result = await this.service.create(dto);

    this.logger.log(`[${correlationId}] Entity created successfully`, {
      id: result.id
    });

    return result;
  } catch (error) {
    this.logger.error(
      `[${correlationId}] Failed to create entity`,
      error.stack,
      { dto, error: error.message }
    );

    if (error instanceof ValidationError) {
      throw new BadRequestException(error.message);
    }

    if (error instanceof UniqueConstraintError) {
      throw new ConflictException('Entity already exists');
    }

    throw new InternalServerErrorException('Failed to create entity');
  }
}

// ‚ùå BAD: No error handling
@Post()
async create(@Body() dto: CreateDto) {
  return this.service.create(dto); // Crashes on error
}
```

**Generator Implementation:**

- Auto-generate try-catch blocks
- Include correlation ID tracking
- Map database errors to HTTP exceptions
- Add structured logging

---

### 2. Logging & Observability

**Required:**

```typescript
export class EnterpriseLogger {
  constructor(
    private readonly context: string,
    private readonly correlationId?: string,
  ) {}

  log(message: string, metadata?: Record<string, any>) {
    console.log(
      JSON.stringify({
        timestamp: new Date().toISOString(),
        level: 'INFO',
        context: this.context,
        correlationId: this.correlationId,
        message,
        ...metadata,
      }),
    );
  }

  error(message: string, trace: string, metadata?: Record<string, any>) {
    console.error(
      JSON.stringify({
        timestamp: new Date().toISOString(),
        level: 'ERROR',
        context: this.context,
        correlationId: this.correlationId,
        message,
        trace,
        ...metadata,
      }),
    );
  }

  warn(message: string, metadata?: Record<string, any>) {
    console.warn(
      JSON.stringify({
        timestamp: new Date().toISOString(),
        level: 'WARN',
        context: this.context,
        correlationId: this.correlationId,
        message,
        ...metadata,
      }),
    );
  }
}
```

**Metrics to Track:**

- Request duration
- Error rates
- Database query performance
- Cache hit/miss ratio
- Memory usage

---

### 3. Security Best Practices

**Input Validation (Multi-Layer):**

```typescript
// Layer 1: DTO Validation
export class CreateUserDto {
  @IsEmail()
  @IsNotEmpty()
  @Transform(({ value }) => value.toLowerCase().trim())
  email: string;

  @IsString()
  @MinLength(8)
  @MaxLength(100)
  @Matches(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])/, {
    message: 'Password must contain uppercase, lowercase, number, and special character',
  })
  password: string;

  @IsString()
  @MinLength(2)
  @MaxLength(50)
  @Matches(/^[a-zA-Z\s'-]+$/, {
    message: 'Name can only contain letters, spaces, hyphens, and apostrophes',
  })
  @Transform(({ value }) => value.trim())
  name: string;
}

// Layer 2: SQL Injection Prevention
export class SecurityValidator {
  static readonly SAFE_COLUMN_PATTERN = /^[a-zA-Z_][a-zA-Z0-9_]*$/;
  static readonly ALLOWED_SORT_ORDERS = ['ASC', 'DESC'] as const;

  static validateColumnName(column: string, allowedColumns: string[]): string {
    if (!this.SAFE_COLUMN_PATTERN.test(column)) {
      throw new BadRequestException('Invalid column name');
    }

    if (!allowedColumns.includes(column)) {
      throw new BadRequestException(`Column '${column}' is not allowed`);
    }

    return column;
  }

  static validateSortOrder(order: string): 'ASC' | 'DESC' {
    const upperOrder = order.toUpperCase();
    if (!this.ALLOWED_SORT_ORDERS.includes(upperOrder as any)) {
      throw new BadRequestException('Invalid sort order');
    }
    return upperOrder as 'ASC' | 'DESC';
  }
}

// Layer 3: Rate Limiting
@Controller('users')
@UseGuards(ThrottlerGuard)
@Throttle(100, 60) // 100 requests per 60 seconds
export class UsersController {
  // ...
}

// Layer 4: CORS & Headers
app.use(
  helmet({
    contentSecurityPolicy: {
      directives: {
        defaultSrc: ["'self'"],
        styleSrc: ["'self'", "'unsafe-inline'"],
        scriptSrc: ["'self'"],
        imgSrc: ["'self'", 'data:', 'https:'],
      },
    },
    hsts: {
      maxAge: 31536000,
      includeSubDomains: true,
      preload: true,
    },
  }),
);
```

**Authentication & Authorization:**

```typescript
// JWT Validation
@Injectable()
export class JwtAuthGuard extends AuthGuard('jwt') {
  handleRequest(err: any, user: any, info: any) {
    if (err || !user) {
      throw new UnauthorizedException('Invalid token');
    }
    return user;
  }
}

// Role-Based Access Control
@Injectable()
export class RolesGuard implements CanActivate {
  constructor(
    private reflector: Reflector,
    private readonly rbacService: RBACService,
  ) {}

  async canActivate(context: ExecutionContext): Promise<boolean> {
    const requiredRoles = this.reflector.get<string[]>('roles', context.getHandler());

    if (!requiredRoles) return true;

    const request = context.switchToHttp().getRequest();
    const user = request.user;

    return this.rbacService.hasAnyRole(user.id, requiredRoles);
  }
}
```

---

### 4. Performance Optimization

**Database Queries:**

```typescript
// ‚úÖ GOOD: Optimized query with indexes
export class UsersRepository {
  async findActiveUsers(page: number, limit: number) {
    // Use indexed columns in WHERE clause
    const query = `
      SELECT
        id, name, email, created_at
      FROM users
      WHERE deleted_at IS NULL
        AND status = 'active'  -- indexed column
      ORDER BY created_at DESC  -- indexed column
      LIMIT $1 OFFSET $2
    `;

    const offset = (page - 1) * limit;
    const result = await this.pool.query(query, [limit, offset]);

    return result.rows;
  }

  // Add count query for pagination
  async countActiveUsers(): Promise<number> {
    const query = `
      SELECT COUNT(*) as total
      FROM users
      WHERE deleted_at IS NULL AND status = 'active'
    `;

    const result = await this.pool.query(query);
    return parseInt(result.rows[0].total);
  }
}

// ‚ùå BAD: Unoptimized query
async findAll() {
  return this.pool.query('SELECT * FROM users'); // No WHERE, no pagination
}
```

**Caching Strategy:**

```typescript
@Injectable()
export class UsersCacheService {
  constructor(
    @Inject(CACHE_MANAGER) private cacheManager: Cache,
    private readonly repository: UsersRepository,
  ) {}

  async findById(id: string): Promise<User> {
    const cacheKey = `user:${id}`;

    // Try cache first
    const cached = await this.cacheManager.get<User>(cacheKey);
    if (cached) {
      return cached;
    }

    // Cache miss - fetch from DB
    const user = await this.repository.findById(id);

    if (user) {
      // Cache for 5 minutes
      await this.cacheManager.set(cacheKey, user, 300);
    }

    return user;
  }

  async invalidate(id: string): Promise<void> {
    await this.cacheManager.del(`user:${id}`);
  }
}
```

**Connection Pooling:**

```typescript
export const databaseConfig = {
  // PostgreSQL
  max: 20, // Maximum pool size
  min: 5, // Minimum pool size
  idleTimeoutMillis: 30000, // Close idle connections
  connectionTimeoutMillis: 2000, // Connection timeout

  // Query timeout
  statement_timeout: 10000, // 10 seconds

  // Keep-alive
  keepAlive: true,
  keepAliveInitialDelayMillis: 10000,
};
```

---

### 5. Testing Standards

**Unit Tests:**

```typescript
describe('UsersService', () => {
  let service: UsersService;
  let repository: jest.Mocked<UsersRepository>;
  let cacheManager: jest.Mocked<Cache>;

  beforeEach(() => {
    repository = {
      create: jest.fn(),
      findById: jest.fn(),
      update: jest.fn(),
      delete: jest.fn(),
    } as any;

    cacheManager = {
      get: jest.fn(),
      set: jest.fn(),
      del: jest.fn(),
    } as any;

    service = new UsersService(repository, cacheManager);
  });

  describe('create', () => {
    it('should create user successfully', async () => {
      const dto = { email: 'test@example.com', name: 'Test' };
      const expected = { id: '1', ...dto };

      repository.create.mockResolvedValue(expected);

      const result = await service.create(dto);

      expect(result).toEqual(expected);
      expect(repository.create).toHaveBeenCalledWith(dto);
    });

    it('should throw ConflictException for duplicate email', async () => {
      const dto = { email: 'existing@example.com', name: 'Test' };

      repository.create.mockRejectedValue(new UniqueConstraintError('Email already exists'));

      await expect(service.create(dto)).rejects.toThrow(ConflictException);
    });

    it('should handle database errors gracefully', async () => {
      const dto = { email: 'test@example.com', name: 'Test' };

      repository.create.mockRejectedValue(new Error('Database error'));

      await expect(service.create(dto)).rejects.toThrow(InternalServerErrorException);
    });
  });
});
```

**Integration Tests:**

```typescript
describe('Users API (e2e)', () => {
  let app: INestApplication;
  let authToken: string;

  beforeAll(async () => {
    const moduleFixture = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleFixture.createNestApplication();
    await app.init();

    // Login to get auth token
    const response = await request(app.getHttpServer())
      .post('/auth/login')
      .send({ email: 'admin@test.com', password: 'password' });

    authToken = response.body.token;
  });

  it('POST /users - should create user', () => {
    return request(app.getHttpServer())
      .post('/users')
      .set('Authorization', `Bearer ${authToken}`)
      .send({ email: 'new@test.com', name: 'New User' })
      .expect(201)
      .expect((res) => {
        expect(res.body).toHaveProperty('id');
        expect(res.body.email).toBe('new@test.com');
      });
  });

  afterAll(async () => {
    await app.close();
  });
});
```

---

### 6. Monitoring & Health Checks

**Health Endpoints:**

```typescript
@Controller('health')
export class HealthController {
  constructor(
    private health: HealthCheckService,
    private db: TypeOrmHealthIndicator,
    @Inject(CACHE_MANAGER) private cache: Cache,
  ) {}

  @Get()
  @HealthCheck()
  check() {
    return this.health.check([
      // Database check
      () => this.db.pingCheck('database'),

      // Redis check
      async () => {
        try {
          await this.cache.set('health-check', 'ok', 5);
          const value = await this.cache.get('health-check');

          return {
            cache: {
              status: value === 'ok' ? 'up' : 'down',
            },
          };
        } catch (error) {
          return {
            cache: {
              status: 'down',
              message: error.message,
            },
          };
        }
      },
    ]);
  }

  @Get('metrics')
  async metrics() {
    return {
      uptime: process.uptime(),
      memory: process.memoryUsage(),
      cpu: process.cpuUsage(),
      timestamp: new Date().toISOString(),
    };
  }
}
```

---

## ‚úÖ Quality Checklist

Before deploying generated code:

- [ ] All endpoints have error handling
- [ ] Structured logging implemented
- [ ] Rate limiting configured
- [ ] Input validation (DTO + SQL)
- [ ] Authentication & authorization
- [ ] Database indexes created
- [ ] Connection pooling configured
- [ ] Health checks implemented
- [ ] Metrics collection enabled
- [ ] Unit tests (>80% coverage)
- [ ] Integration tests
- [ ] API documentation complete
- [ ] Security audit passed

---

**For implementation details**, see `docs/generator/INDEX.md` and feature-specific guides.
