import { ColumnDefinition, TableMetadata } from './types';
import { camelCase, pascalCase, singularize } from './utils';

export interface TemplateContext {
  moduleName: string;
  className: string;
  entityName: string;
  metadata: TableMetadata;
}

export const buildDtoTemplate = (context: TemplateContext): string => {
  const { metadata, className, entityName } = context;
  const createFields = metadata.columns.filter((column) => !column.isPrimaryKey && !column.isGenerated);
  const validators = new Set<string>();

  const importLines = [`import { ApiProperty } from '@nestjs/swagger';`, `import { Type } from 'class-transformer';`];
  if (validators.size > 0) {
    importLines.push(`import { ${Array.from(validators).sort().join(', ')} } from 'class-validator';`);
  }
  importLines.push(`import { PartialType } from '@nestjs/mapped-types';`);

  const createDtoLines = createFields
    .map((column) => {
      const decorator = getValidatorDecorator(column);
      if (decorator) {
        validators.add(decorator.import);
      }
      const propertyLines = [`  @ApiProperty({ description: '${column.comment ?? column.name}'${column.isNullable ? ', required: false' : ''} })`];
      if (decorator) {
        propertyLines.push(...decorator.decoratorLines.map((line) => `  ${line}`));
      }
      propertyLines.push(`  ${camelCase(column.name)}${column.isNullable ? '?' : ''}: ${column.tsType};`);
      return propertyLines.join('\n');
    })
    .join('\n\n');

  const updateDtoLines = `export class Update${entityName}Dto extends PartialType(Create${entityName}Dto) {}`;

  return `/* eslint-disable */
// This file was automatically generated by @ojiepermana/nest-generator.
// <generator-preserve dto.custom-imports>
// Custom imports are preserved between generations.
// </generator-preserve dto.custom-imports>
${importLines.join('\n')}

export class Create${entityName}Dto {
${createDtoLines ? `${createDtoLines}\n` : ''}}

${updateDtoLines}
`;
};

export const buildQueryTemplate = (context: TemplateContext): string => {
  const { metadata, className } = context;
  const selectableColumns = metadata.columns.map((column) => `  "${column.name}"`).join(',\n');
  const insertColumns = metadata.columns
    .filter((column) => !column.isGenerated)
    .map((column) => `  "${column.name}"`)
    .join(',\n');
  const insertValues = metadata.columns
    .filter((column) => !column.isGenerated)
    .map((column, index) => `  $${index + 1}`)
    .join(',\n');
  const updateAssignments = metadata.columns
    .filter((column) => !column.isPrimaryKey && !column.isGenerated)
    .map((column, index) => `  "${column.name}" = $${index + 1}`)
    .join(',\n');

  const primaryKey = metadata.primaryKey?.name ?? 'id';

  return `export const ${className.toUpperCase()}_QUERIES = {
  findAll: \`SELECT\n${selectableColumns}\nFROM "${metadata.schema}"."${metadata.table}"\`,
  findById: \`SELECT\n${selectableColumns}\nFROM "${metadata.schema}"."${metadata.table}"\nWHERE "${primaryKey}" = $1\`,
  insert: \`INSERT INTO "${metadata.schema}"."${metadata.table}" (\n${insertColumns}\n) VALUES (\n${insertValues}\n) RETURNING *\`,
  update: \`UPDATE "${metadata.schema}"."${metadata.table}" SET\n${updateAssignments}\nWHERE "${primaryKey}" = $${metadata.columns.length}\nRETURNING *\`,
  softDelete: \`UPDATE "${metadata.schema}"."${metadata.table}" SET "deleted_at" = NOW() WHERE "${primaryKey}" = $1 RETURNING *\`,
  recap: \`SELECT DATE_TRUNC('month', created_at) AS month, COUNT(*) as total FROM "${metadata.schema}"."${metadata.table}" WHERE EXTRACT('year' FROM created_at) = $1 GROUP BY month ORDER BY month ASC\`,
};
`;
};

export const buildRepositoryTemplate = (context: TemplateContext): string => {
  const { className, entityName, metadata } = context;
  const primaryKey = metadata.primaryKey?.name ?? 'id';
  const primaryTsType = metadata.primaryKey?.tsType ?? 'string';

  return `import { Inject, Injectable } from '@nestjs/common';
import { Pool } from 'pg';
import { FilterQuery, buildFilterQuery } from '@ojiepermana/nest-generator/runtime';
import { ${className.toUpperCase()}_QUERIES } from './${context.moduleName}.query';
import { Create${entityName}Dto, Update${entityName}Dto } from './${context.moduleName}.dto';

export interface ${entityName}Record {
${metadata.columns.map((column) => `  ${camelCase(column.name)}: ${column.tsType};`).join('\n')}
}

@Injectable()
export class ${entityName}Repository {
  constructor(@Inject('PG_POOL') private readonly pool: Pool) {}

  async findAll(filter: FilterQuery = {}): Promise<${entityName}Record[]> {
    const query = buildFilterQuery(${className.toUpperCase()}_QUERIES.findAll, filter);
    const result = await this.pool.query(query.text, query.values);
    return result.rows as ${entityName}Record[];
  }

  async findById(id: ${primaryTsType}): Promise<${entityName}Record | null> {
    const result = await this.pool.query(${className.toUpperCase()}_QUERIES.findById, [id]);
    return result.rows[0] ?? null;
  }

  async create(payload: Create${entityName}Dto): Promise<${entityName}Record> {
    const values = [${metadata.columns
      .filter((column) => !column.isGenerated)
      .map((column) => `payload.${camelCase(column.name)}`)
      .join(', ')}];
    const result = await this.pool.query(${className.toUpperCase()}_QUERIES.insert, values);
    return result.rows[0] as ${entityName}Record;
  }

  async update(id: ${primaryTsType}, payload: Update${entityName}Dto): Promise<${entityName}Record> {
    const values = [${metadata.columns
      .filter((column) => !column.isPrimaryKey && !column.isGenerated)
      .map((column) => `payload.${camelCase(column.name)}`)
      .join(', ')}, id];
    const result = await this.pool.query(${className.toUpperCase()}_QUERIES.update, values);
    return result.rows[0] as ${entityName}Record;
  }

  async softDelete(id: ${primaryTsType}): Promise<${entityName}Record> {
    const result = await this.pool.query(${className.toUpperCase()}_QUERIES.softDelete, [id]);
    return result.rows[0] as ${entityName}Record;
  }

  async recap(year: number): Promise<any[]> {
    const result = await this.pool.query(${className.toUpperCase()}_QUERIES.recap, [year]);
    return result.rows;
  }

  // <generator-preserve repository.custom-methods>
  // Add custom repository methods here
  // </generator-preserve repository.custom-methods>
}
`;
};

export const buildServiceTemplate = (context: TemplateContext): string => {
  const { entityName } = context;

  return `import { CACHE_MANAGER, Inject, Injectable } from '@nestjs/common';
import { Cache } from 'cache-manager';
import { FilterQuery } from '@ojiepermana/nest-generator/runtime';
import { Create${entityName}Dto, Update${entityName}Dto } from './${context.moduleName}.dto';
import { ${entityName}Repository } from './${context.moduleName}.repository';

@Injectable()
export class ${entityName}Service {
  constructor(
    private readonly repository: ${entityName}Repository,
    @Inject(CACHE_MANAGER) private readonly cacheManager: Cache,
  ) {}

  async findAll(filter: FilterQuery = {}): Promise<any[]> {
    const cacheKey = JSON.stringify(filter);
    const cached = await this.cacheManager.get<any[]>(cacheKey);
    if (cached) {
      return cached;
    }
    const result = await this.repository.findAll(filter);
    await this.cacheManager.set(cacheKey, result, 60);
    return result;
  }

  async findOne(id: string): Promise<any | null> {
    return this.repository.findById(id);
  }

  async create(payload: Create${entityName}Dto): Promise<any> {
    const result = await this.repository.create(payload);
    await this.cacheManager.reset();
    return result;
  }

  async update(id: string, payload: Update${entityName}Dto): Promise<any> {
    const result = await this.repository.update(id, payload);
    await this.cacheManager.reset();
    return result;
  }

  async remove(id: string): Promise<any> {
    const result = await this.repository.softDelete(id);
    await this.cacheManager.reset();
    return result;
  }

  async recap(year: number): Promise<any[]> {
    return this.repository.recap(year);
  }

  // <generator-preserve service.custom-methods>
  // Add custom service methods here
  // </generator-preserve service.custom-methods>
}
`;
};

export const buildControllerTemplate = (context: TemplateContext): string => {
  const { entityName, moduleName } = context;
  const route = moduleName.replace(/_/g, '-');

  return `import { Body, Controller, Delete, Get, Param, ParseIntPipe, Patch, Post, Query } from '@nestjs/common';
import { ApiTags } from '@nestjs/swagger';
import { FilterQuery } from '@ojiepermana/nest-generator/runtime';
import { Create${entityName}Dto, Update${entityName}Dto } from './${moduleName}.dto';
import { ${entityName}Service } from './${moduleName}.service';

@ApiTags('${route}')
@Controller('${route}')
export class ${entityName}Controller {
  constructor(private readonly service: ${entityName}Service) {}

  @Get()
  findAll(@Query() filter: FilterQuery) {
    return this.service.findAll(filter);
  }

  @Get('recap')
  recap(@Query('year', ParseIntPipe) year: number) {
    return this.service.recap(year);
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.service.findOne(id);
  }

  @Post()
  create(@Body() payload: Create${entityName}Dto) {
    return this.service.create(payload);
  }

  @Patch(':id')
  update(@Param('id') id: string, @Body() payload: Update${entityName}Dto) {
    return this.service.update(id, payload);
  }

  @Delete(':id')
  remove(@Param('id') id: string) {
    return this.service.remove(id);
  }

  // <generator-preserve controller.custom-routes>
  // Add custom controller routes here
  // </generator-preserve controller.custom-routes>
}
`;
};

export const buildModuleTemplate = (context: TemplateContext): string => {
  const { entityName, moduleName } = context;
  const className = pascalCase(moduleName);

  return `import { Module } from '@nestjs/common';
import { CacheModule } from '@nestjs/cache-manager';
import { ${entityName}Controller } from './${moduleName}.controller';
import { ${entityName}Repository } from './${moduleName}.repository';
import { ${entityName}Service } from './${moduleName}.service';

@Module({
  imports: [CacheModule.register()],
  controllers: [${entityName}Controller],
  providers: [${entityName}Repository, ${entityName}Service],
  exports: [${entityName}Service],
})
export class ${className}Module {}
`;
};

const getValidatorDecorator = (column: ColumnDefinition):
  | {
      import: string;
      decoratorLines: string[];
      lines: string;
    }
  | null => {
  switch (column.tsType) {
    case 'string':
      return {
        import: 'IsString',
        decoratorLines: column.isNullable ? ['@IsString()', '@Type(() => String)'] : ['@IsString()', '@Type(() => String)'],
        lines: `@IsString()\n  ${camelCase(column.name)}: string;`,
      };
    case 'number':
      return {
        import: 'IsNumber',
        decoratorLines: ['@IsNumber()', '@Type(() => Number)'],
        lines: `@IsNumber()\n  ${camelCase(column.name)}: number;`,
      };
    case 'boolean':
      return {
        import: 'IsBoolean',
        decoratorLines: ['@IsBoolean()'],
        lines: `@IsBoolean()\n  ${camelCase(column.name)}: boolean;`,
      };
    case 'Date':
      return {
        import: 'IsDate',
        decoratorLines: ['@IsDate()', '@Type(() => Date)'],
        lines: `@IsDate()\n  ${camelCase(column.name)}: Date;`,
      };
    default:
      return null;
  }
};

export const buildIndexTemplate = (context: TemplateContext): string => {
  const { entityName, moduleName } = context;
  const className = pascalCase(moduleName);

  return `export * from './${moduleName}.module';
export * from './${moduleName}.service';
export * from './${moduleName}.repository';
export * from './${moduleName}.controller';
export * from './${moduleName}.dto';
export { ${entityName}Record } from './${moduleName}.repository';
export { ${className.toUpperCase()}_QUERIES } from './${moduleName}.query';
`;
};

export const buildTemplateContext = (moduleName: string, metadata: TableMetadata): TemplateContext => {
  const entityName = pascalCase(singularize(moduleName));
  const className = pascalCase(moduleName);
  return {
    moduleName,
    className,
    entityName,
    metadata,
  };
};
